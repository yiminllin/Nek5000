c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      udiff  = 0
      utrans = 0

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      parameter(g = 9.81)
      ffx  = 0.
      ffy  = 0.
      ffy  = g*(temp-300.00)
      ffz  = 0.

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      parameter (npts=lx1*ly1*lz1*lelv)
      common /driftv/
     $    cn(npts,ldimt-1),
     $    potent(npts),
     $    rescn(npts,ldimt),
     $    diff_n(npts,ldimt),
     $    mu_n(npts,ldimt),
     $    zvalence(ldimt),
     $    dmask(npts,ldimt),
     $    q_vol(lx1,ly1,lz1,lelv)
      real cn,potent,rescn,zvalence,mu_n,diff_n,dmask
      real q_vol

      qvol = 0.0
      qvol   = 1.0E+7*q_vol(ix,iy,iz,ieg) 
c     qvol   = 1.0E+6
      source = 0.0
      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TSTEP'
      include 'INPUT'
      include 'NEKUSE'

      ux=0.
      uy=0.
      uz=0.
      if (x.le.0) temp=360.00
      if (x.ge.1) temp=300.00
      
      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux=0.0
      uy=0.0
      uz=0.0
      temp=300.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      do iip=1,ldimt1
         ifpsco(iip) = .true.
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      return
      end
c-----------------------------------------------------------------------
      subroutine userchk

      include 'SIZE'  
      include 'TOTAL'
      
      parameter (npts=lx1*ly1*lz1*lelv)
      parameter (lpts=lx1*ly1*lz1*lelv)
      parameter (lxzfl = lx1*lz1*2*ldim*lelt) ! length of face-points
      parameter (nxzfl = lx1*lz1*2*ldim*lelt) ! tot num of face-points
      parameter (nxyz = lx1*ly1)
      parameter (nxzf = lx1)
      parameter (nfaces = 4)
      
      common /driftv/
     $    cn(npts,ldimt-1),
     $    potent(npts),
     $    rescn(npts,ldimt),
     $    diff_n(npts,ldimt),
     $    mu_n(npts,ldimt),
     $    zvalence(ldimt),
     $    dmask(npts,ldimt),
     $    q_vol(lx1,ly1,lz1,lelv)

      common /cembcs/
     $    cemface(2*ldim*lx1*lz1*lelt),
     $    ncemface,
     $    glo_ncemface_pec,glo_ncemface_nmn,glo_ncemface_rob,
     $    ncemface_nmn(ldimt),
     $    ncemface_pec(ldimt),
     $    ncemface_rob(ldimt),
     $    cemface_nmn(lxzfl,ldimt),
     $    cemface_pec(lxzfl,ldimt),
     $    cemface_rob(lxzfl,ldimt)

      real cn,potent,rescn,zvalence,mu_n,diff_n,dmask
      real q_vol
      real mask(npts),bc_flux(lxzfl,ldimt),mult(npts)
      real tmp,wtmp(npts),rhs(npts),h1(npts),h2(npts)
      real h1c(npts,ldimt),h2c(npts,ldimt)
      real gradp(npts,3)
      real gradcn(npts,3)
      integer cemface,ncemface
      integer glo_ncemface_pec,glo_ncemface_nmn,glo_ncemface_rob
      integer ncemface_nmn,ncemface_pec,ncemface_rob
      integer cemface_nmn,cemface_pec,cemface_rob

      real wa(lx1*ly1*lz1*lelt)
      real wb(lx1*ly1*lz1*lelt)
      real wc(lx1*ly1*lz1*lelt)
      real wn(lx1*ly1*lz1*lelt)
      real w_h1(lx1*ly1*lz1*lelt)
      real w_h2(lx1*ly1*lz1*lelt)


      integer isd,imsh,maxit,ic
      real    tol
      integer  ifld,i,i0,i1,j,l1,l2,l3,e,f
      integer k,l,ef,js1,jf1,jskip1,js2,jf2,jskip2,j1,j2,p
      character CB*3
      integer iglsum

      
      ! ==============
      ! One time run
      ! ==============
      if (istep.eq.0) then

          ! ==============
          ! Initialize Var
          ! ==============
          call rzero(cn,npts*ldimt)
          call rzero(potent,npts)

          ! z_k
          zvalence(1) =  1.0 ! Na
          zvalence(2) = -1.0 ! Cl
          zvalence(3) =  1.0 ! K 
          zvalence(4) = -1.0 ! OH

          ! mu_n = u_n*F  (Faraday const: 96500)
          ! diff_n = D_n
          do i= 1,npts 
#if 0
             mu_n    (i,1) =  5.1917E-10
             mu_n    (i,2) =  7.913E-10 
             mu_n    (i,3) =  7.6235E-10
             mu_n    (i,4) =  2.0651E-9 
             diff_n  (i,1) =  1.33E-11
             diff_n  (i,2) =  2.03E-11 
             diff_n  (i,3) =  1.96E-11
             diff_n  (i,4) =  5.30E-11
#endif
             mu_n    (i,1) =  1.0E-1
             mu_n    (i,2) =  1.5E-1
             mu_n    (i,3) =  1.2E-1
             mu_n    (i,4) =  2.0E-1
             diff_n  (i,1) =  0.9E-1
             diff_n  (i,2) =  1.4E-1
             diff_n  (i,3) =  1.2E-1
             diff_n  (i,4) =  1.9E-1
          enddo

          ! =================
          ! Initial Condition
          ! =================
           do i = 1,npts
            cn(i,1) = 0.0 ! Na
            cn(i,2) = 0.0 ! Cl
            cn(i,3) = 3.0 ! K
            cn(i,4) = 3.0 ! OH
            potent(i) = 0.0 ! phi
          enddo
 
          ! =================
          ! Setup face cemface_ptr
          ! =================
          call dsset(lx1,ly1,lz1)
          k = 0
          l = 0
          do e = 1,lelt
             do f = 1,nfaces
                ef = eface(f)
                js1 = skpdat(1,f)
                jf1 = skpdat(2,f)
                jskip1 = skpdat(3,f)
                js2 = skpdat(4,f)
                jf2 = skpdat(5,f)
                jskip2 = skpdat(6,f)

                i = 0
                do j2 = js2,jf2,jskip2
                   do j1 = js1,jf1,jskip1
                      i = i+1
                      l = l+1
c     Face numbering.
                      k = i+nxzf*(ef-1)+nxzf*nfaces*(e-1)
c     Global number; `cemface` gets Ed's numbering at faces following
c     pff order.
                      cemface(k) = j1+nx1*(j2-1)+nxyz*(e-1)
                   enddo
                enddo
                ncemface = l
             enddo
          enddo

          if (nid_io.eq.0) then
             write(6,*) 'done: cem_set_fc_ptr, ncemface= ',ncemface
          endif

          ! ====================
          ! cemface_pec nmn 
          ! ====================

          i0= 1
          i1= ldimt
          
          do ifld= i0,i1
             l1=0
             l2=0
             l3=0
          do e= 1,nelt
          do f= 1,nfaces
          do j= 1,nxzf
             CB= CBC(f,e,ifld+1)
             i =(e-1)*nfaces*nxzf+(f-1)*nxzf+j !global face numbering
             if  (CB.eq.'N  ') then
                l1= l1+1
                cemface_nmn(l1,ifld)= i
             elseif  (CB.eq.'PEC') then
                l2= l2+1
                cemface_pec(l2,ifld)= i
             elseif  (CB.eq.'R  ') then
                l3= l3+1
                cemface_rob(l3,ifld)= i
             endif
          enddo
          enddo
          enddo

          ncemface_nmn(ifld)  = l1
          ncemface_pec(ifld)  = l2
          ncemface_rob(ifld)  = l3
          enddo

          do ifld=i0,i1    

            glo_ncemface_pec= iglsum(ncemface_pec(ifld),1)
            glo_ncemface_nmn= iglsum(ncemface_nmn(ifld),1)
            glo_ncemface_rob= iglsum(ncemface_rob(ifld),1)

            if (nid.eq.0) then
             write(6,*) 'tot#pts: BCs ncemface_pec',ifld,glo_ncemface_pec
             write(6,*) 'tot#pts: BCs ncemface_nmn',ifld,glo_ncemface_nmn
             write(6,*) 'tot#pts: BCs ncemface_rob',ifld,glo_ncemface_rob
            endif

          enddo

          ! ============
          ! Setup dmask
          ! ============
          do i = 1,ldimt
            call rone(dmask(1,i),npts)
            do e=1,nelt
              do f=1,nfaces
                CB =CBC(f,e,i+1)
                if (CB.eq.'PEC') then
                    call facev (dmask(1,i),e,f,0.0,lx1,ly1,lz1)
                endif
              enddo
            enddo
          enddo

          ! ============
          ! Setup multiplicity 
          ! ============
          call rone    (mult,npts)
          call dssum   (mult,lx1,ly1,lz1)
          call invcol1 (mult,npts)

      endif

      call rzero(rescn,npts*ldimt)
      call rzero(bc_flux,lxzfl*ldimt)

      ! ==========
      ! Debugging
      ! ==========
      write(6,*) 'Calling userchk'
      write(6,*) 'ldimt', ldimt
      write(6,*) 'npts', npts
      write(6,*) 'istep', istep 
      write(6,*) 'dt', dt 
      write(6,*) 'ifxyo,ifvo,ifpo,ifto', ifxyo,ifvo,ifpo,ifto
      do iip=1,ldimt1
         write(6,*) 'ifpsco(iip), iip', iip, ifpsco(iip)
      enddo
      
      ! ====================
      ! Enforce Dirichlet BC
      ! ====================
      if (ncemface_pec(1).ge.1)  then ! first field Na
         do i=1,ncemface_pec(1)
            j = cemface_pec(i,1)
            i0 = cemface(j)
            cn(i0,1) = 1.0
         enddo
      endif


      if (ncemface_pec(2).ge.1)  then ! second field Cl
         do i=1,ncemface_pec(2)
            j = cemface_pec(i,2) 
            i0 = cemface(j)      
            cn(i0,2) = 1.0
         enddo

      endif

      if (ncemface_pec(3).ge.1)  then ! third field K
         do i=1,ncemface_pec(3)
            j = cemface_pec(i,3)
            i0 = cemface(j)
            cn(i0,3) = 0.0
         enddo
      endif

      if (ncemface_pec(4).ge.1)  then ! fifth field OH
         do i=1,ncemface_pec(4)
            j = cemface_pec(i,4)
            i0 = cemface(j)
            cn(i0,4) = 0.0
         enddo

      endif

      ! =============
      ! solve poisson
      ! =============
c...  set rhs = -\sum z_k D_k \Delta c_k
      call rzero(w_h2,npts)
      call rzero(rhs,npts)
      call rzero(wn,npts)
      do ic = 1,ldimt-1
        call cmult2(w_h1,diff_n(1,ic),-1.0*zvalence(ic),npts)
        call axhelm(wn,cn(1,ic),w_h1,w_h2,1,1)
        call add2(rhs,wn,npts)
      enddo

c...  setup helmholtz: [h1 A + h2 B] u = rhs where u = u_0+u_b
      call rzero(h1,npts)
      call copy (mask,dmask(1,5),npts)

c       h1 = \sum z_k^2 u_k F c_k
      call rzero(wn,npts)
      call rzero (h1,npts)
      do ic = 1,ldimt-1
        call col3(wn,mu_n(1,ic),cn(1,ic),npts) ! assume z_k^2 = 1
        call add2(h1,wn,npts) 
      enddo
      call rzero (h2,npts)

      isd = 1
      imsh = 1
      maxit = 5000
      tol = param(22)

c...  setup helmholtz: [h1 A + h2 B] u_0 = rhs - h1 A u_b
c     call bcneusc (wa,npts,5,-1)
      call col2 (wa,h1,npts)
      call add2 (h2,wa,npts)
c     call bcdirsc (potent,npts,1)    
      call axhelm (wa,potent,h1,h2,1,1) 
      call sub3 (wb,rhs,wa,npts) ! wb = rhs-wa       
c     call bcneusc (wa,npts,5,1)    
      call rzero(wa,npts)
      if (ncemface_nmn(5).gt.0) then
        do i = 1,ncemface_nmn(5)
          j = cemface_nmn(i,5)
          k = cemface(j)
          wa(k) = wa(k) + bc_flux(j,5)*area(j,1,1,1)
        enddo
      endif
      call col2 (wa,h1,npts)
      call add2 (wb,wa,npts) 

c...  solve u_0 after assemble and mask for boundary on right hand side  
      call dssum (wb,lx1,ly1,lz1)
      call col2 (wb,mask,npts)
      call cggo2 (wa,wb,h1,h2,mult,mask,imsh,isd,npts,tol,maxit)
      
c...  add u = u_0 + u_b (u_0= potent, u_b=potent_b if applicable)  
      call add2(potent,wa,npts)
     
      call opgrad (gradp(1,1),gradp(1,2),gradp(1,3),potent)

      call chsign(gradp(1,1),npts)
      call chsign(gradp(1,2),npts)
      call chsign(gradp(1,3),npts)


      ! ===============
      ! solve transport
      ! ===============

! TODO: ldimt
      do ic = 1,ldimt-1   ! loop through species
        call cmult2(h1c(1,ic),diff_n(1,ic),dt,npts) 
        call rone(h2c(1,ic),npts)
      enddo

! TODO: ldimt
      do ic = 1,ldimt-1
        
        !!! RHS
        call rzero(w_h2,npts)
        call col3(wn,cn(1,ic),bm1,npts)
        call add2s1(rescn(1,ic),wn,dt,npts)
        call col3(w_h1,cn(1,ic),mu_n(1,ic),npts)
        call axhelm(wn,potent,w_h1,w_h2,1,1)
        call add2s2(rescn(1,ic),wn,-1.0*zvalence(ic)*dt,npts)

        call rzero(gradcn,npts)
        call opgrad (gradcn(1,1),gradcn(1,2),gradcn(1,3),
     &               cn(1,ic))
        call vdot2(wn,gradcn(1,1),gradcn(1,2),
     &             vx,vy,npts)
        call add2s2(rescn(1,ic),wn,-1.0*dt,npts)

        call rzero(w_h2,npts)
        call col3(w_h1,cn(1,ic),diff_n(1,ic),npts)
        call invcol2(w_h1,t(1,1,1,1,1),npts)
        call invcol2(w_h1,t(1,1,1,1,1),npts)
        call axhelm(wn,t(1,1,1,1,1),w_h1,w_h2,1,1)
        call add2s2(rescn(1,ic),wn,-1.0*dt,npts)

        !!! LHS
        call copy(wa,rescn(1,ic),npts)
        call copy(wb,mu_n(1,ic),npts)
        call copy(wc,cn(1,ic),npts)

        if (ncemface_nmn(ic).gt.0) then
          do i = 1,ncemface_nmn(ic)
            j = cemface_nmn(ic,1)
            k = cemface(j)
            tmp = gradp(k,1)*unx(j,1,1,1)+gradp(k,2)*uny(j,1,1,1)
     $          + gradp(k,3)*unz(j,1,1,1)
            wa(k) = wa(k) 
     $            - tmp*zvalence(ic)*dt*wc(k)*wb(k)*area(j,1,1,1)
          enddo
        endif
        call copy(rescn(1,ic),wa,npts)

        call col2 (wa,h1c(1,ic),npts)
        call add2 (h2c(1,ic),wa,npts)
        call axhelm (wa,cn(1,ic),h1c(1,ic),h2c(1,ic),1,1)
        call sub3 (wb,rescn(1,ic),wa,npts) 
        call rzero(wa,npts)
        call col2 (wa,h1c(1,ic),npts) 
        call add2 (wb,wa,npts) 
          
        isd = 1
        imsh = 1
        maxit = 5000
        tol = param(22)

        call dssum (wb,lx1,ly1,lz1)
        call col2 (wb,dmask(1,ic),npts)

! TODO:
c       call cggo2(wa,wb,h1c(1,ic),h2c(1,ic)
c    $            ,mult,dmask(1,ic),imsh,isd,npts,tol,maxit)
        call cggo2(wa,wb,h1c(1,ic),h2c(1,ic)
     $            ,mult,dmask(1,1),imsh,isd,npts,tol,maxit)


        call add2 (cn(1,ic),wa,npts)

      enddo

      ! Correction step for neutrality... only a hard fix
      call rzero(wa,npts)
      do ic = 2,ldimt-1
        call add2s2(wa,cn(1,ic),zvalence(ic),npts)
      enddo
      call cmult2(cn(1,1),wa,-1.0*zvalence(1),npts) 
      call rzero(wa,npts)

      call copy(t(1,1,1,1,2),cn(1,1),npts)
      call copy(t(1,1,1,1,3),cn(1,2),npts)
      call copy(t(1,1,1,1,4),cn(1,3),npts)
      call copy(t(1,1,1,1,5),cn(1,4),npts)
      call copy(t(1,1,1,1,6),potent,npts)
      
      call rzero(q_vol,npts)
      do ic = 1,ldimt-2
        call rzero(w_h2,npts)
        call copy(w_h1,diff_n,npts)
        call axhelm(wn,cn(1,ic),w_h1,w_h2,1,1)
        call add2(q_vol,wn,npts)
      enddo

      return


      end


c=======================================================================
      subroutine cggo2(x,f,h1,h2,mult,mask,imsh,isd,n,tol,niter)
c=======================================================================
      include 'SIZE'
      include 'GEOM'
      include 'MASS'
      include 'TSTEP'
      include 'INPUT'
      include 'FDMH1'

      parameter (lpts=lx1*ly1*lz1*lelv)
      common  /srcuz/ d(lpts),r(lpts),w(lpts),p(lpts),z(lpts)
      common  /srccg/ scalar(2)
      real     tol,r,w,p,z,scalar
      logical ifio

c     Solve Ax=f where A is SPD and is invoked by the routine ax()
c
c     Output:  x - vector of length n
c
c     Input:   f - vector of length n
c
c     Work arrays:   r,w,p,z  - vectors of length n
c
c     User-provided routine ax(w,z,n) returns  w := Az,
c
c     User-provided routine solveM(z,r,n) ) returns  z := M^-1 r,
c
c     User-provided array wght() is used to scale inner-products
c     of the form (p,z) = p'*wght*z
c
      integer  n,niter,imsh,isd
      real     eps, rhsnorm
      real     x(n),f(n),h1(n),h2(n),mult(n),mask(n)
      real     bminv(n)
      logical  ifmcor
!$ACC DATA CREATE(r,w,p,z,d)
      call rzero  (r,n)      ! init
      call rzero  (w,n)      ! init
      call rzero  (p,n)      ! init
      call rzero  (z,n)      ! init

c     set machine tolerances
C     one = 1.
C     eps = 1.e-20
C     rhsnorm = sqrt(glsc2(f,f,n))
C     if (one+eps .eq. one) eps = 1.e-14
C     if (one+eps .eq. one) eps = 1.e-7
C     eps= eps*rhsnorm


c     if (nid.eq.0) write(6,*) 'start: cggo2'
c     if (nid.eq.0) write(6,5) tol,n,niter
c  5  format(' tol=',e15.7,', n=',i6, ', iter=',i6)

      pap = 0.0
      vol = volvm1

      call rone   (bminv,n)
      call invcol2(bminv,bm1,n)

      kfldfdm=1

      if (param(23).eq.1) call setprec(D,h1,h2,imsh,isd)       !IFFDM=true
!FIXME - MJO - 5/9/15 - Skipped set_fdm_prec_h1b for acc
      if (param(23).eq.2) call set_fdm_prec_h1b(d,h1,h2,nel)

      call copy   (r,f,n) ! f=b-Ax_0
      call rzero  (x,n)
      call rzero  (p,n)

c...  check non-trivial null-space: "ifmcor := if mean correction is true"
c...  choose the non-trivial solution that has zero mean; this is equivalent to
c...  orthogonalization to one vector (1,....,1) of length n
c...
c...  eg), A= [ 2 0 ]  u=[1/2,0] or u[1/2,10] for Au=0
c...          [ 0 0 ]
c...       Our routine will give result of u=[1/2,1/2]

      ifmcor= .false.
      h2max = glmax(h2  ,n)
      skmin = glmin(mask,n)                ! check dirichlet boundary
      if ((skmin.gt.0).and.(h2max.eq.0)) ifmcor = .true.  ! no dirichlet, no h2 term

      if (ifmcor) then
          smean = -1./glsum(bm1,n)         ! glsum(bmn)= volume integration    
          rmean = smean*glsc2(r,mult,n)    !
          call copy  (x,bm1,n)
          call dssum (x,nx1,ny1,nz1)
          call add2s2(r,x,rmean,n)         ! r = r - rmean*x
          call rzero (x,n)
      endif

      rtz1= 1.0
      do iter=1,niter

         if     (param(23).eq.1) then
             call col3(z,r,d,n)
         elseif (param(23).eq.2) then
!FIXME - MJO - 5/9/15 - Skipped fdm_h1b for acc
             call fdm_h1(z,r,d,mask,mult,nel,ktype(1,1,kfldfdm),w)
         else
             call copy(z,r,n)
         endif

         if (ifmcor) then
             rmean = smean*glsc2(z,bm1,n)  ! inner product could give different numbers on different # cores.   
             call cadd(z,rmean,n)          ! if do "sort" and then "glsc2" might give the same value all the time.
         endif

         rtz2      = rtz1
         scalar(1) = vlsc3 (r,mult,z,n)    ! tmp=tmp+r(i)*mult(i)*z(i)                      
         scalar(2) = vlsc32(r,mult,bminv,n)! tmp=tmp+r(i)*mult(i)*r(i)/bm1(i)
         call gop(scalar,w,'+  ',2)

         rtz1 = scalar(1)
         rbn2 = sqrt(scalar(2)/vol)        ! rbn2= norm(r,2)

         if (iter.eq.1) rbn0 = rbn2

         if ((nid.eq.0).and.(istep.le.5))
     $           write(6,1001) iter-1,ifmcor,rbn2,rbn0,tol,istep
         if (rbn2.le.tol) go to 1000

         beta = rtz1/rtz2

         if  (iter.eq.1) beta=0.0
         call add2s1  (p,z,beta,n)         ! p = z + beta*p
         call axhelm (w,p,h1,h2,imsh,isd) ! w = Ap
!         call axhelm2 (w,p,h1,h2,imsh,isd) ! w = Ap
         call dssum   (w,nx1,ny1,nz1)      !
         call col2    (w,mask,n)           !

         pap  = glsc3 (w,mult,p,n)        ! pap  = (p^T)Ap
         alpha= rtz1/pap                  ! alpha= (r^T r)/pap
         alphm= -alpha

         call add2s2 (x,p,alpha,n)         ! x = x + alpha*p
         call add2s2 (r,w,alphm,n)         ! r = r + alphm*(Ap)

      enddo
 1000 continue
!$ACC END DATA
      if (nid.eq.0) then
         if (param(23).eq.1) then
             if ((mod(istep,iocomm).eq.0).or.(istep.le.2))
     $       write(6,1003) istep,iter,ifmcor,rbn2,rbn0,tol
         else
             if ((mod(istep,iocomm).eq.0).or.(istep.le.2))
     $       write(6,1002) istep,iter,ifmcor,rbn2,rbn0,tol
         endif
      endif

 1001 format(i5,l4,2x,1p3e12.4,i8,' cggo2')
 1002 format(' ',i9,' cggo2   : iteration#',i5,l4,2x,1p3e12.4)
 1003 format(' ',i9,' cggo2   : iteration#',i5,l4,2x,1p3e12.4,
     $       '    | diagonal = T ')

      return
      end


