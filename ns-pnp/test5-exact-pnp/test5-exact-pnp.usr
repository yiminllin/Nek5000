c-----------------------------------------------------------------------
      subroutine exactsol(uu,vv,pp,cc1,cc2,pphi,tt,npts)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      
      integer npts,i 
      real uu(nx1,ny1,nz1,nelt),vv(nx1,ny1,nz1,nelt)
      real pp(nx2,ny2,nz2,nelt),cc1(nx1,ny1,nz1,nelt)
      real cc2(nx1,ny1,nz1,nelt),pphi(nx1,ny1,nz1,nelt)
      real tmpu,tmpv,tmpp
      real xx,yy,tt
      
      do e = 1,nelv
      do i = 1,nx1
      do j = 1,ny1
      do k = 1,nz1
        xx = xm1(i,j,k,e)
        yy = ym1(i,j,k,e)
        call exactsol_i(uu(i,j,k,e),vv(i,j,k,e),pp(i,j,k,e),
     &                  cc1(i,j,k,e),cc2(i,j,k,e),pphi(i,j,k,e),
     &                  tt,xx,yy)
      enddo
      enddo
      enddo
      enddo
      
      end
c-----------------------------------------------------------------------
      subroutine exactsol_i(ui,vi,pri,c1i,c2i,phii,tt,xx,yy)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NSPNP'
      
      integer i,j,k,e
      real ui,vi,pri,c1i,c2i,phii
      real xx,yy,tt

      ui   = 0.0
      vi   = 0.0
      pri  = 0.0
      c1i  = a0+a1*cos(ac*pi*xx)*cos(bcc*pi*yy)
     &            *exp(-(ac**2+bcc**2)*Dcst*tt*pi*pi)
      c2i  = a0+a1*cos(ac*pi*xx)*cos(bcc*pi*yy)
     &            *exp(-(ac**2+bcc**2)*Dcst*tt*pi*pi)
      phii = ga*log(c1i)

      end
c-----------------------------------------------------------------------
      subroutine uservp(i,j,k,eg) ! set variable properties
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer i,j,k,e,eg
      e = gllel(eg)

      udiff  = 1.0
      utrans = 1.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userf(i,j,k,eg) ! set acceleration term
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NSPNP'
      integer i,j,k,e,eg
      real xx,yy,tt
      real ct,st,spx,cpx,stpx,ctpx
      real spy,cpy,stpy,ctpy
      real c1ex

      e  = gllel(eg)
      xx = xm1(i,j,k,e)
      yy = ym1(i,j,k,e)
      tt = time

      ffx = 0.0
      ffy = 0.0 
      ffz = 0.0

      end
c-----------------------------------------------------------------------
      subroutine userq(i,j,k,eg) ! set source term
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'	  
      include 'NSPNP'

      integer i,j,k,e,eg
      real exactc
      real xx,yy,tt

      e = gllel(eg)
      xx = xm1(i,j,k,e)
      yy = ym1(i,j,k,e)
      tt = time
            
      ! TODO: hardcoded z_i, D_i
      exactc = a0+a1*cos(ac*pi*xx)*cos(bcc*pi*yy)
     &        *exp(-(ac**2+bcc**2)*Dcst*tt*pi*pi)
      if (ifield.eq.ic1) then   ! c1
      !   qvol = -z1*D1cst*ga*(ac**2+bcc**2)*(pi**2)*(exactc-a0)
        qvol = -migration(i,j,k,e)
      endif
      if (ifield.eq.ic2) then   ! c2
      !   qvol = -z2*D2cst*ga*(ac**2+bcc**2)*(pi**2)*(exactc-a0)
        qvol = -migration(i,j,k,e)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc(i,j,k,f,eg) ! set up boundary conditions
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NSPNP' 

      common /exacu/ ue(lx1,ly1,lz1,lelt),ve(lx1,ly1,lz1,lelt)
      common /exacp/ pe(lx2,ly2,lz2,lelt)
      common /exacd/ ud(lx1,ly1,lz1,lelt),vd(lx1,ly1,lz1,lelt)
     $              ,pd(lx2,ly2,lz2,lelt)
      common /exacg/ xo(lx1,ly1,lz1,lelt),yo(lx1,ly1,lz1,lelt),
     $               zo(lx1,ly1,lz1,lelt)
      
      real tmppri,xx,yy,tmpv1,tmpv2
      integer i,j,k,f,e,eg,npts
      npts = nx1*ny1*nz1*nelv
      e    = gllel(eg)
      
      xx = xm1(i,j,k,e)
      yy = ym1(i,j,k,e)
      
      uz   = 0.0
      flux = 0.0
      if (ifield.eq.ic1) then   ! c1
        call exactsol_i(ux,vy,pri,temp,tmpv1,tmpv2,time,xx,yy)
      endif
	if (ifield.eq.ic2) then   ! c2
        call exactsol_i(ux,vy,pri,tmpv1,temp,tmpv2,time,xx,yy)
      endif
	if (ifield.eq.iphi) then   ! phi
        call exactsol_i(ux,vy,pri,tmpv1,tmpv2,temp,time,xx,yy)
      endif 

      return
      end
c-----------------------------------------------------------------------
      subroutine useric(i,j,k,eg) ! set up initial conditions
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NSPNP'
      integer i,j,k,e,eg
      real xx,yy

      e  = gllel(eg)
      xx = xm1(i,j,k,e)
      yy = ym1(i,j,k,e)

      ux   = 0.0
      uy   = 0.0
      uz   = 0.0
      if (ifield.eq.ic1) then   ! c1
        call exactsol_i(ux,vy,pri,temp,tmpv1,tmpv2,0.0,xx,yy)
      endif
	if (ifield.eq.ic2) then   ! c2
        call exactsol_i(ux,vy,pri,tmpv1,temp,tmpv2,0.0,xx,yy)
      endif
	if (ifield.eq.iphi) then   ! phi
        call exactsol_i(ux,vy,pri,tmpv1,tmpv2,temp,0.0,xx,yy)
      endif 

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat   ! This routine to modify element vertices
      include 'SIZE'
      include 'TOTAL'
 
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'

      ifflow = .false.
      ifheat = .false.
      idpss(ic1-1) = -1.0
      idpss(ic2-1) = -1.0
      idpss(iphi-1) = -1.0
      
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      include 'NSPNP'

      ic1 = 2
      ic2 = 3
      iphi = 4

      a0  = 2.0
      a1  = 1.0
      ! au  = 11.0
      ! ap  = 12.0
      ! bp  = 10.0
      ac  = 3.0
      bcc = 4.0
      Rey = 1/param(2)
      Pec = 1/param(8)

      z1 = 1.0
      z2 = -1.0
      D1cst = 1.0/Pec
      D2cst = 2.0/Pec
      ga = (-z1*D1cst-z2*D2cst)/(z1**2*D1cst+z2**2*D2cst) 
      Dcst = (z1*ga+1.0)*D1cst
      
      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NSPNP'
      
      common /exacu/ ue(lx1,ly1,lz1,lelt),ve(lx1,ly1,lz1,lelt)
      common /exacp/ pe(lx2,ly2,lz2,lelt)
      common /exacc/ c1e(lx1,ly1,lz1,lelt),c2e(lx1,ly1,lz1,lelt)
      common /exacphi/ phie(lx1,ly1,lz1,lelt)
      common /exacd/ ud(lx1,ly1,lz1,lelt),vd(lx1,ly1,lz1,lelt)
     $              ,pd(lx2,ly2,lz2,lelt),c1d(lx1,ly1,lz1,lelt)
     $              ,c2d(lx1,ly1,lz1,lelt),phid(lx1,ly1,lz1,lelt)
     $              ,c1c2d(lx1,ly1,lz1,lelt)
      common /exacg/ xo(lx1,ly1,lz1,lelt),yo(lx1,ly1,lz1,lelt),
     $               zo(lx1,ly1,lz1,lelt)
      
      integer npts,npts2
      real c1dx,c1mx,c1nm
      real c2dx,c2mx,c2nm
      real phidx,phimx,phinm
      real c1c2dx,c1c2mx

      ifield = 1
      npts  = nx1*ny1*nz1*nelv
      npts2 = nx2*ny2*nz2*nelv

      write(6,*) '====== Calling userchk'

      ! Solve passive scalar, assume ifsplit = T, ifgeom = F
      ! First solve fluid (in nek_advance), then passive scalar (contrary to the original Nek)
      write(6,*) 'ifsplit,ifgeom',ifsplit,ifgeom,idpss
      do igeom=1,ngeom
        call pnp_solve(igeom)
      enddo
      ifheat = .false.
      idpss(ic1-1) = -1.0
      idpss(ic2-1) = -1.0
      idpss(iphi-1) = -1.0

      ! Initialize vdiff
      call cfill(vdiff(1,1,1,1,ic1),D1cst,npts)
      call cfill(vdiff(1,1,1,1,ic2),D2cst,npts)

      call exactsol(ue,ve,pe,c1e,c2e,phie,time,npts)

c     if (istep.eq.0) call outpost(ue,ve,c1e,pe,t,'   ')

      ! PNP Solve
      call pnp_poisson

      ! Calculate errors
      call sub3    (ud,ue,vx,npts)
      call sub3    (vd,ve,vy,npts)
      call sub3    (pd,pe,pr,npts2)
      call sub3    (c1d,c1e,t(1,1,1,1,ic1-1),npts)
      call sub3    (c2d,c2e,t(1,1,1,1,ic2-1),npts)
      call sub3    (phid,phie,t(1,1,1,1,iphi-1),npts)
      ! TODO: Shift exact pressure by a constant
      call cadd    (pe,-pd(1,1,1,1),npts2)
      call sub3    (pd,pe,pr,npts2)
      call cadd    (phie,-phid(1,1,1,1),npts2)
      call sub3    (phid,phie,t(1,1,1,1,iphi-1),npts2)
      
      call sub3    (c1c2d,t(1,1,1,1,ic1-1)
     &             ,t(1,1,1,1,ic2-1),npts)

      if (istep.eq.nsteps) call outpost(ud,vd,c1d,pd,t,'err')

      umx = glamax(ud,npts)/glamax(ue,npts)
      vmx = glamax(vd,npts)/glamax(ve,npts)
      pmx = glamax(pd,npts2)/glamax(pe,npts2)
      uex = glamax(ue,npts)
      vex = glamax(ve,npts)
      pex = glamax(pe,npts2)
      udx = gl2norm(ud,npts)/gl2norm(ue,npts)
      vdx = gl2norm(vd,npts)/gl2norm(ve,npts)
      pdx = gl2norm(pd,npts2)/gl2norm(pe,npts2)

      unm = gl2norm(vx,npts)
      vnm = gl2norm(vy,npts)
      pnm = gl2norm(pd,npts)

      c1mx = glamax(c1d,npts)/glamax(c1e,npts)
      c1dx = gl2norm(c1d,npts)/gl2norm(c1e,npts)
      c1nm = gl2norm(t(1,1,1,1,ic1-1),npts)

      c2mx = glamax(c2d,npts)/glamax(c2e,npts)
      c2dx = gl2norm(c2d,npts)/gl2norm(c2e,npts)
      c2nm = gl2norm(t(1,1,1,1,ic2-1),npts)

      phimx = glamax(phid,npts)/glamax(phie,npts)
      phidx = gl2norm(phid,npts)/gl2norm(phie,npts)
      phinm = gl2norm(t(1,1,1,1,iphi-1),npts)

      c1c2dx = gl2norm(c1c2d,npts)
      c1c2dm = glamax(c1c2d,npts)

      if (nid.eq.0) then       ! l2err, 
         write(6,11) istep,time,udx,umx,unm,'  X err'
         write(6,11) istep,time,vdx,vmx,vnm,'  Y err'
         write(6,12) istep,time,pdx,pmx,pnm,'                P err'
         write(6,11) istep,time,c1dx,c1mx,c1nm,'  C1 err'
         write(6,11) istep,time,c2dx,c2mx,c2nm,'  C2 err'
         write(6,11) istep,time,phidx,phimx,phinm,'  phi err'
         write(6,11) istep,time,c1c2dx,c1c2dm,c1c2dx,'  enuetral'
   11    format(i5,1p4e14.6,a7)
   12    format(i5,1p4e14.6,a21)
      endif  
      
      if (istep.le.5) then                   ! Use exact solution to bootstrap
        call copy(vx,ue,npts)
        call copy(vy,ve,npts)
        call copy(pr,pe,npts2)
        call copy(t(1,1,1,1,ic1-1),c1e,npts)
        call copy(t(1,1,1,1,ic2-1),c2e,npts)
        call copy(t(1,1,1,1,iphi-1),phie,npts)
      endif

      ! call copy(t(1,1,1,1,1),c1e,npts)
      ! call copy(t(1,1,1,1,2),c2e,npts)
      ! call copy(t(1,1,1,1,3),phie,npts)
      ! call copy(t(1,1,1,1,1),t(1,1,1,1,3),npts)

!       call outpost(t(1,1,1,1,1),t(1,1,1,1,2),t(1,1,1,1,3)
!      &            ,t(1,1,1,1,3),t,'   ')

      return
      end
c-----------------------------------------------------------------------
      subroutine pnp_poisson
c     
      include 'SIZE'
      include 'TOTAL'
      include 'ORTHOT' ! hsolve proj
      include 'NSPNP'
      
      real h1(lt)
     $   , h2(lt)
     $   , t1(lt)
     $   , t2(lt)

      real kappae(lx1,ly1,lz1,lelt)
      real rhs_phie(lx1,ly1,lz1,lelt)
      real tmparr(lx1,ly1,lz1,lelt)
      real phi_e(lx1,ly1,lz1,lelt)
      integer idx,xi,yi,zi,ei
      real xx,yy,tt,exactc

      n = lx1*ly1*lz1*nelt

      isd = 1
      imsh = 1
      maxit = 200
      idpss(iphi-1)=0 ! active solver
      ifield = iphi

      ! TODO: refactor
      ! Construct kappae = \sum D_i c_i, rhsphie = -\nabla \cdot (\sum z_i D_i \nabla c_i)
      tt = time
      do ei = 1,nelt
      do xi = 1,lx1
      do yi = 1,ly1
      do zi = 1,lz1
        xx = xm1(xi,yi,zi,ei)
        yy = ym1(xi,yi,zi,ei)
        exactc = a0+a1*cos(ac*pi*xx)*cos(bcc*pi*yy)
     &          *exp(-(ac**2+bcc**2)*Dcst*tt*pi*pi)
        kappae(xi,yi,zi,ei) = (D1cst*exactc
     &                        +D2cst*exactc)
      enddo
      enddo
      enddo
      enddo
      call rzero(h2,n)

      call rzero(rhs_phie,n)
      call cfill(h1,-z1*D1cst,n)
      call axhelm(rhs_phie,t(1,1,1,1,1),h1,h2,imsh,isd)
      call cfill(h1,-z2*D2cst,n)
      call axhelm(tmparr,t(1,1,1,1,2),h1,h2,imsh,isd)
      call add2(rhs_phie,tmparr,n)
      call dssum(rhs_phie,lx1,ly1,lz1)               ! TODO: do we need dssum?
      call col2(rhs_phie,binvm1,n)
! 
      call sethlm(h1,h2,0)
      call copy(h1,kappae,n)

      call bcneusc (t2,-1) ! robin
      call Xaddcol3(h2,t2,h1,n) ! h2=h2+t2*h1

      call bcdirsc(phi_e) ! dirichlet
      call axhelm (t1,phi_e,h1,h2,imsh,isd)
	  
      call col3(t2,rhs_phie,bm1,n)	
	
      call sub2(t2,t1,n)

      call bcneusc (t1,1) ! neumann
      call col2(t1,h1,n)
      call add2(t2,t1,n)

      call hsolve   ('POTE',T1,T2,H1,H2
     $              ,tmask(1,1,1,1,ifield-1)
     $              ,tmult(1,1,1,1,ifield-1)
     $              ,imsh,tolht(ifield),maxit,isd
     $              ,approxt(1,0,ifield-1),napproxt(1,ifield-1)
     $              ,bintm1)
      call add2(phi_e,t1,n) ! u = u_0 + u_b

      call copy(t(1,1,1,1,iphi-1),phi_e,n)

      phie_max = glmax(phi_e,n)
      phie_min = glmin(phi_e,n)
      if(nid.eq.0) then
       write(6,*) 'phie max/min : ', phie_max,'/',phie_min
      endif

      idpss(iphi-1)=-1 ! disalbe in timestep

      return
      end
c-----------------------------------------------------------------------
      subroutine pnp_solve(igeom)
C
C     Driver for temperature or passive scalar.
C
C     Current version:
C     (1) Varaiable properties.
C     (2) Implicit time stepping.
C     (3) User specified tolerance for the Helmholtz solver
C         (not based on eigenvalues).
C     (4) A passive scalar can be defined on either the 
C         temperatur or the velocity mesh.
C     (5) A passive scalar has its own multiplicity (B.C.).  
C
      include 'SIZE'
      include 'INPUT'
      include 'TSTEP'
      include 'DEALIAS'
      include 'NSPNP'      

      real*8 ts, dnekclock

      ts = dnekclock()

      if (nio.eq.0 .and. igeom.eq.2) 
     &    write(*,'(13x,a)') 'Solving for Hmholtz scalars'

      do ifield = 2,nfield
      !    if (idpss(ifield-1).eq.0) then      ! helmholtz
            intype        = -1
            if (.not.iftmsh(ifield)) imesh = 1
            if (     iftmsh(ifield)) imesh = 2
            call unorm
            call settolt
            call pnp_cdscal(igeom)
      !    endif
      enddo

      if (nio.eq.0 .and. igeom.eq.2)
     &   write(*,'(4x,i7,a,1p2e12.4)') 
     &   istep,'  Scalars done',time,dnekclock()-ts

      return
      end
c-----------------------------------------------------------------------
      subroutine pnp_cdscal (igeom)
C
C     Solve the pnp equation
C
      include 'SIZE'
      include 'INPUT'
      include 'GEOM'
      include 'MVGEOM'
      include 'SOLN'
      include 'MASS'
      include 'TSTEP'
      include 'NSPNP'
      COMMON  /CPRINT/ IFPRINT
      LOGICAL          IFPRINT
      LOGICAL          IFCONV

      COMMON /SCRNS/ TA(LX1,LY1,LZ1,LELT)
     $              ,TB(LX1,LY1,LZ1,LELT)
      COMMON /SCRVH/ H1(LX1,LY1,LZ1,LELT)
     $              ,H2(LX1,LY1,LZ1,LELT)

      include 'ORTHOT'
      
      integer i,j,k,e
      real exactc
      real xx,yy,tt
      real tmparr(lx1,ly1,lz1,lelt)
      real h1tmp(lt)
      real h2tmp(lt)
      real tmpnorm
      real w1(lx1,ly1,lz1,lelt)
      real w2(lx1,ly1,lz1,lelt)
      real w3(lx1,ly1,lz1,lelt)
      real tx(lx1,ly1,lz1,lelt)
      real ty(lx1,ly1,lz1,lelt)
      real tz(lx1,ly1,lz1,lelt)

      ifld1 = ifield-1
      napproxt(1,ifld1) = laxtt

      nel    = nelfld(ifield)
      n   = lx1*ly1*lz1*nel

      !  bq = migration term = \nabla \cdot (z_i D_i c_i \nabla \phi)
      call rzero(migration,n)
      call rzero(h2tmp,n)
      call copy(h1tmp,t(1,1,1,1,ifield-1),n)
      if (ifield.eq.ic1) then
        call cmult(h1tmp,z1*D1cst,n)
      endif
      if (ifield.eq.ic2) then
        call cmult(h1tmp,z2*D2cst,n)
      endif
      call axhelm(migration,t(1,1,1,1,iphi-1)
     &           ,h1tmp,h2tmp,imsh,isd)
      call dssum(migration,lx1,ly1,lz1)            ! TODO: dssum?
      call col2(migration,binvm1,n)

      if (igeom.eq.1) then   ! geometry at t^{n-1}

         call makeq
         call lagscal

      else                   ! geometry at t^n

         IF (IFPRINT) THEN
            IF (IFIELD.EQ.2.AND.NID.EQ.0)
     $          WRITE (6,*) ' Temperature/Passive scalar solution'
         ENDIF

         if1=ifield-1
         write(name4t,1) if1-1
    1    format('PS',i2)
         if(ifield.eq.2) write(name4t,'(A4)') 'TEMP'

C
C        New geometry
C
         isd = 1
         if (ifaxis.and.ifaziv.and.ifield.eq.2) isd = 2
c        if (ifaxis.and.ifmhd) isd = 2 !This is a problem if T is to be T!

         do 1000 iter=1,nmxnl ! iterate for nonlin. prob. (e.g. radiation b.c.)

         intype = 0
         if (iftran) intype = -1
         call sethlm  (h1,h2,intype)
         call bcneusc (ta,-1)
         call add2    (h2,ta,n)
         call add2    (h2,adq(1,1,1,1,ifield-1),n)
         call bcdirsc (t(1,1,1,1,ifield-1))
         call axhelm  (ta,t(1,1,1,1,ifield-1),h1,h2,imesh,ISD)

         call sub3    (tb,bq(1,1,1,1,ifield-1),ta,n)
      !    call sub3    (tb,migration,ta,n)

         call bcneusc (ta,1)
         call add2    (tb,ta,n)

         if(iftmsh(ifield)) then
           call hsolve  (name4t,TA,TB,H1,H2 
     $                   ,tmask(1,1,1,1,ifield-1)
     $                   ,tmult(1,1,1,1,ifield-1)
     $                   ,imesh,tolht(ifield),nmxt(ifield-1),1
     $                   ,approxt(1,0,ifld1),napproxt(1,ifld1),bintm1)
         else
           call hsolve  (name4t,TA,TB,H1,H2 
     $                   ,tmask(1,1,1,1,ifield-1)
     $                   ,tmult(1,1,1,1,ifield-1)
     $                   ,imesh,tolht(ifield),nmxt(ifield-1),1
     $                   ,approxt(1,0,ifld1),napproxt(1,ifld1),binvm1)
         endif 

         call add2    (t(1,1,1,1,ifield-1),ta,n)

         call cvgnlps (ifconv) ! Check convergence for nonlinear problem 
         if (ifconv) goto 2000

C        Radiation case, smooth convergence, avoid flip-flop (ER).
         call cmult (ta,0.5,n)
         call sub2  (t(1,1,1,1,ifield-1),ta,n)

 1000    continue
 2000    continue

      endif

      return
      end

