c-----------------------------------------------------------------------
      subroutine exactsol(uu,vv,pp,cc1,cc2,pphi,tt,npts)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      
      integer npts,i 
      real uu(nx1,ny1,nz1,nelt),vv(nx1,ny1,nz1,nelt)
      real pp(nx2,ny2,nz2,nelt),cc1(nx1,ny1,nz1,nelt)
      real cc2(nx1,ny1,nz1,nelt),pphi(nx1,ny1,nz1,nelt)
      real tmpu,tmpv,tmpp
      real xx,yy,tt
      
      do e = 1,nelv
      do i = 1,nx1
      do j = 1,ny1
      do k = 1,nz1
        xx = xm1(i,j,k,e)
        yy = ym1(i,j,k,e)
        call exactsol_i(uu(i,j,k,e),vv(i,j,k,e),pp(i,j,k,e),
     &                  cc1(i,j,k,e),cc2(i,j,k,e),pphi(i,j,k,e),
     &                  tt,xx,yy)
      enddo
      enddo
      enddo
      enddo
      
      end
c-----------------------------------------------------------------------
      subroutine exactsol_i(ui,vi,pri,c1i,c2i,phii,tt,xx,yy)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NSPNP'
      
      integer i,j,k,e
      real ui,vi,pri,c1i,c2i,phii
      real xx,yy,tt

      ui   = 0.0
      vi   = 0.0
      pri  = 0.0
      c1i  = a0+a1*cos(ac*pi*xx)*cos(bcc*pi*yy)
     &            *exp(-(ac**2+bcc**2)*Dcst*tt*pi*pi)
      c2i  = a0+a1*cos(ac*pi*xx)*cos(bcc*pi*yy)
     &            *exp(-(ac**2+bcc**2)*Dcst*tt*pi*pi)
      phii = ga*log(c1i)

      end
c-----------------------------------------------------------------------
      subroutine uservp(i,j,k,eg) ! set variable properties
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer i,j,k,e,eg
      e = gllel(eg)

      udiff  = 1.0
      utrans = 1.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userf(i,j,k,eg) ! set acceleration term
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NSPNP'
      integer i,j,k,e,eg
      real xx,yy,tt
      real ct,st,spx,cpx,stpx,ctpx
      real spy,cpy,stpy,ctpy
      real c1ex

      e  = gllel(eg)
      xx = xm1(i,j,k,e)
      yy = ym1(i,j,k,e)
      tt = time

      ffx = 0.0
      ffy = 0.0 
      ffz = 0.0

      end
c-----------------------------------------------------------------------
      subroutine userq(i,j,k,eg) ! set source term
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'	  
      include 'NSPNP'

      integer i,j,k,e,eg
      real exactc
      real xx,yy,tt

      e = gllel(eg)
      xx = xm1(i,j,k,e)
      yy = ym1(i,j,k,e)
      tt = time
            
      ! TODO: hardcoded z_i, D_i
      exactc = a0+a1*cos(ac*pi*xx)*cos(bcc*pi*yy)
     &        *exp(-(ac**2+bcc**2)*Dcst*tt*pi*pi)
      if (ifield.eq.ic1) then   ! c1
        qvol = -z1*D1cst*ga*(ac**2+bcc**2)*(pi**2)*(exactc-a0)
      endif
      if (ifield.eq.ic2) then   ! c2
        qvol = -z2*D2cst*ga*(ac**2+bcc**2)*(pi**2)*(exactc-a0)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc(i,j,k,f,eg) ! set up boundary conditions
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NSPNP' 

      common /exacu/ ue(lx1,ly1,lz1,lelt),ve(lx1,ly1,lz1,lelt)
      common /exacp/ pe(lx2,ly2,lz2,lelt)
      common /exacd/ ud(lx1,ly1,lz1,lelt),vd(lx1,ly1,lz1,lelt)
     $              ,pd(lx2,ly2,lz2,lelt)
      common /exacg/ xo(lx1,ly1,lz1,lelt),yo(lx1,ly1,lz1,lelt),
     $               zo(lx1,ly1,lz1,lelt)
      
      real tmppri,xx,yy,tmpv1,tmpv2
      integer i,j,k,f,e,eg,npts
      npts = nx1*ny1*nz1*nelv
      e    = gllel(eg)
      
      xx = xm1(i,j,k,e)
      yy = ym1(i,j,k,e)
      
      uz   = 0.0
      flux = 0.0
      if (ifield.eq.ic1) then   ! c1
        call exactsol_i(ux,vy,pri,temp,tmpv1,tmpv2,time,xx,yy)
      endif
	if (ifield.eq.ic2) then   ! c2
        call exactsol_i(ux,vy,pri,tmpv1,temp,tmpv2,time,xx,yy)
      endif
	if (ifield.eq.iphi) then   ! phi
        call exactsol_i(ux,vy,pri,tmpv1,tmpv2,temp,time,xx,yy)
      endif 

      return
      end
c-----------------------------------------------------------------------
      subroutine useric(i,j,k,eg) ! set up initial conditions
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NSPNP'
      integer i,j,k,e,eg
      real xx,yy

      e  = gllel(eg)
      xx = xm1(i,j,k,e)
      yy = ym1(i,j,k,e)

      ux   = 0.0
      uy   = 0.0
      uz   = 0.0
      if (ifield.eq.ic1) then   ! c1
        call exactsol_i(ux,vy,pri,temp,tmpv1,tmpv2,0.0,xx,yy)
      endif
	if (ifield.eq.ic2) then   ! c2
        call exactsol_i(ux,vy,pri,tmpv1,temp,tmpv2,0.0,xx,yy)
      endif
	if (ifield.eq.iphi) then   ! phi
        call exactsol_i(ux,vy,pri,tmpv1,tmpv2,temp,0.0,xx,yy)
      endif 

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat   ! This routine to modify element vertices
      include 'SIZE'
      include 'TOTAL'
 
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'

      ifflow = .false.
      
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      include 'NSPNP'

      ic1 = 2
      ic2 = 3
      iphi = 4

      a0  = 2.0
      a1  = 1.0
      ! au  = 11.0
      ! ap  = 12.0
      ! bp  = 10.0
      ac  = 3.0
      bcc = 4.0
      Rey = 1/param(2)
      Pec = 1/param(8)

      z1 = 1.0
      z2 = -1.0
      D1cst = 1.0/Pec
      D2cst = 2.0/Pec
      ga = (-z1*D1cst-z2*D2cst)/(z1**2*D1cst+z2**2*D2cst) 
      Dcst = (z1*ga+1.0)*D1cst
      
      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NSPNP'
      
      common /exacu/ ue(lx1,ly1,lz1,lelt),ve(lx1,ly1,lz1,lelt)
      common /exacp/ pe(lx2,ly2,lz2,lelt)
      common /exacc/ c1e(lx1,ly1,lz1,lelt),c2e(lx1,ly1,lz1,lelt)
      common /exacphi/ phie(lx1,ly1,lz1,lelt)
      common /exacd/ ud(lx1,ly1,lz1,lelt),vd(lx1,ly1,lz1,lelt)
     $              ,pd(lx2,ly2,lz2,lelt),c1d(lx1,ly1,lz1,lelt)
     $              ,c2d(lx1,ly1,lz1,lelt),phid(lx1,ly1,lz1,lelt)
     $              ,c1c2d(lx1,ly1,lz1,lelt)
      common /exacg/ xo(lx1,ly1,lz1,lelt),yo(lx1,ly1,lz1,lelt),
     $               zo(lx1,ly1,lz1,lelt)
      
      integer npts,npts2
      real c1dx,c1mx,c1nm
      real c2dx,c2mx,c2nm
      real phidx,phimx,phinm
      real c1c2dx,c1c2mx

      ifield = 1
      npts  = nx1*ny1*nz1*nelv
      npts2 = nx2*ny2*nz2*nelv

      ! Initialize vdiff
      call cfill(vdiff(1,1,1,1,ic1),D1cst,npts)
      call cfill(vdiff(1,1,1,1,ic2),D2cst,npts)

      call exactsol(ue,ve,pe,c1e,c2e,phie,time,npts)

c     if (istep.eq.0) call outpost(ue,ve,c1e,pe,t,'   ')

      ! PNP Solve
      call pnp_poisson

      ! Calculate errors
      call sub3    (ud,ue,vx,npts)
      call sub3    (vd,ve,vy,npts)
      call sub3    (pd,pe,pr,npts2)
      call sub3    (c1d,c1e,t(1,1,1,1,ic1-1),npts)
      call sub3    (c2d,c2e,t(1,1,1,1,ic2-1),npts)
      call sub3    (phid,phie,t(1,1,1,1,iphi-1),npts)
      ! TODO: Shift exact pressure by a constant
      call cadd    (pe,-pd(1,1,1,1),npts2)
      call sub3    (pd,pe,pr,npts2)
      call cadd    (phie,-phid(1,1,1,1),npts2)
      call sub3    (phid,phie,t(1,1,1,1,iphi-1),npts2)
      
      call sub3    (c1c2d,t(1,1,1,1,ic1-1)
     &             ,t(1,1,1,1,ic2-1),npts)

      if (istep.eq.nsteps) call outpost(ud,vd,c1d,pd,t,'err')

      umx = glamax(ud,npts)/glamax(ue,npts)
      vmx = glamax(vd,npts)/glamax(ve,npts)
      pmx = glamax(pd,npts2)/glamax(pe,npts2)
      uex = glamax(ue,npts)
      vex = glamax(ve,npts)
      pex = glamax(pe,npts2)
      udx = gl2norm(ud,npts)/gl2norm(ue,npts)
      vdx = gl2norm(vd,npts)/gl2norm(ve,npts)
      pdx = gl2norm(pd,npts2)/gl2norm(pe,npts2)

      unm = gl2norm(vx,npts)
      vnm = gl2norm(vy,npts)
      pnm = gl2norm(pd,npts)

      c1mx = glamax(c1d,npts)/glamax(c1e,npts)
      c1dx = gl2norm(c1d,npts)/gl2norm(c1e,npts)
      c1nm = gl2norm(t(1,1,1,1,ic1-1),npts)

      c2mx = glamax(c2d,npts)/glamax(c2e,npts)
      c2dx = gl2norm(c2d,npts)/gl2norm(c2e,npts)
      c2nm = gl2norm(t(1,1,1,1,ic2-1),npts)

      phimx = glamax(phid,npts)/glamax(phie,npts)
      phidx = gl2norm(phid,npts)/gl2norm(phie,npts)
      phinm = gl2norm(t(1,1,1,1,iphi-1),npts)

      c1c2dx = gl2norm(c1c2d,npts)
      c1c2dm = glamax(c1c2d,npts)

      if (nid.eq.0) then       ! l2err, 
         write(6,11) istep,time,udx,umx,unm,'  X err'
         write(6,11) istep,time,vdx,vmx,vnm,'  Y err'
         write(6,12) istep,time,pdx,pmx,pnm,'                P err'
         write(6,11) istep,time,c1dx,c1mx,c1nm,'  C1 err'
         write(6,11) istep,time,c2dx,c2mx,c2nm,'  C2 err'
         write(6,11) istep,time,phidx,phimx,phinm,'  phi err'
         write(6,11) istep,time,c1c2dx,c1c2dm,c1c2dx,'  enuetral'
   11    format(i5,1p4e14.6,a7)
   12    format(i5,1p4e14.6,a21)
      endif  
      
      if (istep.le.5) then                   ! Use exact solution to bootstrap
        call copy(vx,ue,npts)
        call copy(vy,ve,npts)
        call copy(pr,pe,npts2)
        call copy(t(1,1,1,1,ic1-1),c1e,npts)
        call copy(t(1,1,1,1,ic2-1),c2e,npts)
        call copy(t(1,1,1,1,iphi-1),phie,npts)
      endif

      ! call copy(t(1,1,1,1,1),c1e,npts)
      ! call copy(t(1,1,1,1,2),c2e,npts)
      ! call copy(t(1,1,1,1,3),phie,npts)

      ! call copy(t(1,1,1,1,1),t(1,1,1,1,3),npts)
      ! call copy(t(1,1,1,1,1),phie,npts)
!       call outpost(t(1,1,1,1,1),t(1,1,1,1,2),t(1,1,1,1,3)
!      &            ,t(1,1,1,1,3),t,'   ')

      return
      end
c-----------------------------------------------------------------------
      subroutine pnp_poisson
c     
      include 'SIZE'
      include 'TOTAL'
      include 'ORTHOT' ! hsolve proj
      include 'NSPNP'
      
      parameter(lt=lx1*ly1*lz1*lelt)

      real h1(lt)
     $   , h2(lt)
     $   , t1(lt)
     $   , t2(lt)

      real kappae(lx1,ly1,lz1,lelt)
      real rhs_phie(lx1,ly1,lz1,lelt)
      real phi_e(lx1,ly1,lz1,lelt)
      integer idx,xi,yi,zi,ei
      real xx,yy,tt,exactc

      n = lx1*ly1*lz1*nelt

      isd = 1
      imsh = 1
      maxit = 200
      idpss(iphi-1)=0 ! active solver
      ifield = iphi

      ! TODO: refactor
      ! Construct kappae = \sum D_i c_i, rhsphie = -\nabla \cdot (\sum z_i D_i \nabla c_i)
      tt = time
      do ei = 1,nelt
      do xi = 1,lx1
      do yi = 1,ly1
      do zi = 1,lz1
        xx = xm1(xi,yi,zi,ei)
        yy = ym1(xi,yi,zi,ei)
        exactc = a0+a1*cos(ac*pi*xx)*cos(bcc*pi*yy)
     &          *exp(-(ac**2+bcc**2)*Dcst*tt*pi*pi)
        kappae(xi,yi,zi,ei) = (D1cst*exactc
     &                        +D2cst*exactc)
        rhs_phie(xi,yi,zi,ei) = 
     &    -(z1*D1cst+z2*D2cst)*(ac**2+bcc**2)*(pi**2)*(exactc-a0)
      enddo
      enddo
      enddo
      enddo
      call rzero(h2,n)

      call sethlm(h1,h2,0)
      call copy(h1,kappae,n)

      call bcneusc (t2,-1) ! robin
      call Xaddcol3(h2,t2,h1,n) ! h2=h2+t2*h1

      call bcdirsc(phi_e) ! dirichlet
      call axhelm (t1,phi_e,h1,h2,imsh,isd)
	  
      call col3(t2,rhs_phie,bm1,n)	
	
      call sub2(t2,t1,n)

      call bcneusc (t1,1) ! neumann
      call col2(t1,h1,n)
      call add2(t2,t1,n)

      call hsolve   ('POTE',T1,T2,H1,H2
     $              ,tmask(1,1,1,1,ifield-1)
     $              ,tmult(1,1,1,1,ifield-1)
     $              ,imsh,tolht(ifield),maxit,isd
     $              ,approxt(1,0,ifield-1),napproxt(1,ifield-1)
     $              ,bintm1)
      call add2(phi_e,t1,n) ! u = u_0 + u_b

      call copy(t(1,1,1,1,iphi-1),phi_e,n)

      phie_max = glmax(phi_e,n)
      phie_min = glmin(phi_e,n)
      if(nid.eq.0) then
       write(6,*) 'phie max/min : ', phie_max,'/',phie_min
      endif

      idpss(iphi-1)=-1 ! disalbe in timestep

      return
      end
